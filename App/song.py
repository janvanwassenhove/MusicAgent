'''
This file contains the Song class that represents a song and handles the creation of the song file.
'''
import os
import re

from typing_extensions import final

from .songCreationData import SongCreationData
class Song:
    def __init__(self, name, logger):
        self.name = name
        self.song_dir = ""
        self.logger = logger
        self.draft_count = 1

    def get_song_dir(self):
        return self.song_dir

    def create_song_file(self, song_creation_data):
        self.logger.info("\nCreating the song file.")
        print("\nCreating the song file.")

        # Create the songs directory if it doesn't exist
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(current_dir)  # Set project_root to the parent directory
        songs_directory = os.path.join(project_root, 'Songs')
        if not os.path.exists(songs_directory):
            os.makedirs(songs_directory)
        # Create the subdirectory for the song
        song_directory = os.path.join(songs_directory, self.name)
        if not os.path.exists(song_directory):
           os.makedirs(song_directory)

        header = f"# --{self.name.upper()}-- \n# Generated by mITy.John music's agency. \n\n"
        if not song_creation_data.sonicpi_code.startswith(header):
            song_creation_data.sonicpi_code = header + song_creation_data.sonicpi_code

        # Full path samples in the sonic pi code for song (excluded from parameter to avoid sending to openai, anthropic, ...)
        project_directory = os.path.join(project_root, "Samples")
        finalcode = re.sub(
            r'sample\s+"([^"]+)"',
            lambda match: f'sample "{os.path.normpath(f"{project_directory}/{match.group(1)}").replace("\\", "\\\\")}"',
            song_creation_data.sonicpi_code
        )

        self.song_dir = song_directory
        self.logger.info("Writing song to directory: " + self.song_dir)
        self.logger.info("sonic pi code " + finalcode)

        song_file = os.path.join(self.song_dir, self.name + '.rb')

        # Check if the file already exists
        if os.path.exists(song_file):
            # Compare the existing file content with the new content
            with open(song_file, 'r') as existing_file:
                existing_content = existing_file.read()
            if existing_content != finalcode:
                # Find the next available index for renaming
                index = 1
                while True:
                    new_song_file = os.path.join(self.song_dir, f"{self.name}_{index}.rb")
                    if not os.path.exists(new_song_file):
                        os.rename(song_file, new_song_file)
                        break
                    index += 1

        # Write the new content to the song file
        with open(song_file, 'w') as f:
            f.write(finalcode)

    def create_readme_file(self, song_creation_data):
        readme_file = os.path.join(self.song_dir, 'README.md')

        self.logger.info("\nCreating the readme file.")

        readme_content = (
            f"# --- {self.name} ---"
            f"\n Generated by mITy.John music's agency. \n\n"
            f"![Album Cover]({self.name}.png)\n"
            f"\n\nLyrics: \n{song_creation_data.lyrics}\n\n"
            f"---\n\n"
            f"## Song Parameters\n"
            f"Song Prompt: {song_creation_data.song_description}\n\n"
            f"Theme: {song_creation_data.theme}\n\n"
            f"Melody: {song_creation_data.melody}\n\n"
            f"Rhythm: {song_creation_data.rhythm}\n\n"
            f"Structure: {song_creation_data.structure}\n\n"
            f"Segments: {song_creation_data.segments}\n\n"
            f"Total Duration: {song_creation_data.total_duration} seconds\n\n\n"
            f"Arrangements: {song_creation_data.arrangements}\n\n\n"
        )

        # Write the content to README.md
        with open(readme_file, 'w', encoding='utf-8') as file:
            file.write(readme_content)


